{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useLinking;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _core = require(\"@react-navigation/core\");\nvar _nonSecure = require(\"nanoid/non-secure\");\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _ServerContext = _interopRequireDefault(require(\"./ServerContext\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _regeneratorRuntime() { \"use strict\"; _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar createMemoryHistory = function createMemoryHistory() {\n  var index = 0;\n  var items = [];\n  var pending = [];\n  var interrupt = function interrupt() {\n    pending.forEach(function (it) {\n      var cb = it.cb;\n      it.cb = function () {\n        return cb(true);\n      };\n    });\n  };\n  var history = {\n    get index() {\n      var _window$history$state;\n      var id = (_window$history$state = window.history.state) === null || _window$history$state === void 0 ? void 0 : _window$history$state.id;\n      if (id) {\n        var _index = items.findIndex(function (item) {\n          return item.id === id;\n        });\n        return _index > -1 ? _index : 0;\n      }\n      return 0;\n    },\n    get: function get(index) {\n      return items[index];\n    },\n    backIndex: function backIndex(_ref) {\n      var path = _ref.path;\n      for (var i = index - 1; i >= 0; i--) {\n        var item = items[i];\n        if (item.path === path) {\n          return i;\n        }\n      }\n      return -1;\n    },\n    push: function push(_ref2) {\n      var path = _ref2.path,\n        state = _ref2.state;\n      interrupt();\n      var id = (0, _nonSecure.nanoid)();\n      items = items.slice(0, index + 1);\n      items.push({\n        path: path,\n        state: state,\n        id: id\n      });\n      index = items.length - 1;\n      window.history.pushState({\n        id: id\n      }, '', path);\n    },\n    replace: function replace(_ref3) {\n      var path = _ref3.path,\n        state = _ref3.state;\n      var _window$history$state2, _window$history$state3;\n      interrupt();\n      var id = (_window$history$state2 = (_window$history$state3 = window.history.state) === null || _window$history$state3 === void 0 ? void 0 : _window$history$state3.id) !== null && _window$history$state2 !== void 0 ? _window$history$state2 : (0, _nonSecure.nanoid)();\n      if (items.length) {\n        items[index] = {\n          path: path,\n          state: state,\n          id: id\n        };\n      } else {\n        items.push({\n          path: path,\n          state: state,\n          id: id\n        });\n      }\n      window.history.replaceState({\n        id: id\n      }, '', path);\n    },\n    go: function go(n) {\n      interrupt();\n      if (n > 0) {\n        n = Math.min(n, items.length - 1);\n      } else if (n < 0) {\n        n = index + n < 0 ? -index : n;\n      }\n      if (n === 0) {\n        return;\n      }\n      index += n;\n      return new Promise(function (resolve, reject) {\n        var done = function done(interrupted) {\n          clearTimeout(timer);\n          if (interrupted) {\n            reject(new Error('History was changed during navigation.'));\n            return;\n          }\n          var title = window.document.title;\n          window.document.title = '';\n          window.document.title = title;\n          resolve();\n        };\n        pending.push({\n          ref: done,\n          cb: done\n        });\n        var timer = setTimeout(function () {\n          var index = pending.findIndex(function (it) {\n            return it.ref === done;\n          });\n          if (index > -1) {\n            pending[index].cb();\n            pending.splice(index, 1);\n          }\n        }, 100);\n        var onPopState = function onPopState() {\n          var last = pending.pop();\n          window.removeEventListener('popstate', onPopState);\n          last === null || last === void 0 ? void 0 : last.cb();\n        };\n        window.addEventListener('popstate', onPopState);\n        window.history.go(n);\n      });\n    },\n    listen: function listen(listener) {\n      var onPopState = function onPopState() {\n        if (pending.length) {\n          return;\n        }\n        listener();\n      };\n      window.addEventListener('popstate', onPopState);\n      return function () {\n        return window.removeEventListener('popstate', onPopState);\n      };\n    }\n  };\n  return history;\n};\nvar findMatchingState = function findMatchingState(a, b) {\n  if (a === undefined || b === undefined || a.key !== b.key) {\n    return [undefined, undefined];\n  }\n  var aHistoryLength = a.history ? a.history.length : a.routes.length;\n  var bHistoryLength = b.history ? b.history.length : b.routes.length;\n  var aRoute = a.routes[a.index];\n  var bRoute = b.routes[b.index];\n  var aChildState = aRoute.state;\n  var bChildState = bRoute.state;\n  if (aHistoryLength !== bHistoryLength || aRoute.key !== bRoute.key || aChildState === undefined || bChildState === undefined || aChildState.key !== bChildState.key) {\n    return [a, b];\n  }\n  return findMatchingState(aChildState, bChildState);\n};\nvar series = function series(cb) {\n  var handling = false;\n  var queue = [];\n  var callback = function _callee() {\n    var last;\n    return _regeneratorRuntime().async(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          if (!handling) {\n            _context.next = 4;\n            break;\n          }\n          queue.unshift(callback);\n          return _context.abrupt(\"return\");\n        case 4:\n          handling = true;\n          _context.next = 7;\n          return _regeneratorRuntime().awrap(cb());\n        case 7:\n          _context.prev = 7;\n          handling = false;\n          if (queue.length) {\n            last = queue.pop();\n            last === null || last === void 0 ? void 0 : last();\n          }\n          return _context.finish(7);\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }, null, null, [[0,, 7, 11]], Promise);\n  };\n  return callback;\n};\nvar isUsingLinking = false;\nfunction useLinking(ref, _ref4) {\n  var independent = _ref4.independent,\n    _ref4$enabled = _ref4.enabled,\n    enabled = _ref4$enabled === void 0 ? true : _ref4$enabled,\n    config = _ref4.config,\n    _ref4$getStateFromPat = _ref4.getStateFromPath,\n    getStateFromPath = _ref4$getStateFromPat === void 0 ? _core.getStateFromPath : _ref4$getStateFromPat,\n    _ref4$getPathFromStat = _ref4.getPathFromState,\n    getPathFromState = _ref4$getPathFromStat === void 0 ? _core.getPathFromState : _ref4$getPathFromStat,\n    _ref4$getActionFromSt = _ref4.getActionFromState,\n    getActionFromState = _ref4$getActionFromSt === void 0 ? _core.getActionFromState : _ref4$getActionFromSt;\n  React.useEffect(function () {\n    if (independent) {\n      return undefined;\n    }\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(['Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:', \"- You are not using both 'linking' prop and 'useLinking'\", \"- You don't have 'useLinking' in multiple components\"].join('\\n').trim());\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n    return function () {\n      isUsingLinking = false;\n    };\n  });\n  var _React$useState = React.useState(createMemoryHistory),\n    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 1),\n    history = _React$useState2[0];\n  var enabledRef = React.useRef(enabled);\n  var configRef = React.useRef(config);\n  var getStateFromPathRef = React.useRef(getStateFromPath);\n  var getPathFromStateRef = React.useRef(getPathFromState);\n  var getActionFromStateRef = React.useRef(getActionFromState);\n  React.useEffect(function () {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n    getActionFromStateRef.current = getActionFromState;\n  });\n  var server = React.useContext(_ServerContext.default);\n  var getInitialState = React.useCallback(function () {\n    var value;\n    if (enabledRef.current) {\n      var _server$location;\n      var _location = (_server$location = server === null || server === void 0 ? void 0 : server.location) !== null && _server$location !== void 0 ? _server$location : typeof window !== 'undefined' ? window.location : undefined;\n      var path = _location ? _location.pathname + _location.search : undefined;\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n    var thenable = {\n      then: function then(onfulfilled) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch: function _catch() {\n        return thenable;\n      }\n    };\n    return thenable;\n  }, []);\n  var previousIndexRef = React.useRef(undefined);\n  var previousStateRef = React.useRef(undefined);\n  var pendingPopStatePathRef = React.useRef(undefined);\n  React.useEffect(function () {\n    previousIndexRef.current = history.index;\n    return history.listen(function () {\n      var _previousIndexRef$cur;\n      var navigation = ref.current;\n      if (!navigation || !enabled) {\n        return;\n      }\n      var path = location.pathname + location.search;\n      var index = history.index;\n      var previousIndex = (_previousIndexRef$cur = previousIndexRef.current) !== null && _previousIndexRef$cur !== void 0 ? _previousIndexRef$cur : 0;\n      previousIndexRef.current = index;\n      pendingPopStatePathRef.current = path;\n      var record = history.get(index);\n      if ((record === null || record === void 0 ? void 0 : record.path) === path && record !== null && record !== void 0 && record.state) {\n        navigation.resetRoot(record.state);\n        return;\n      }\n      var state = getStateFromPathRef.current(path, configRef.current);\n      if (state) {\n        var rootState = navigation.getRootState();\n        if (state.routes.some(function (r) {\n          return !(rootState !== null && rootState !== void 0 && rootState.routeNames.includes(r.name));\n        })) {\n          console.warn(\"The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.\");\n          return;\n        }\n        if (index > previousIndex) {\n          var action = getActionFromStateRef.current(state, configRef.current);\n          if (action !== undefined) {\n            try {\n              navigation.dispatch(action);\n            } catch (e) {\n              console.warn(\"An error occurred when trying to handle the link '\" + path + \"': \" + e.message);\n            }\n          } else {\n            navigation.resetRoot(state);\n          }\n        } else {\n          navigation.resetRoot(state);\n        }\n      } else {\n        navigation.resetRoot(state);\n      }\n    });\n  }, [enabled, history, ref]);\n  React.useEffect(function () {\n    var _ref$current;\n    if (!enabled) {\n      return;\n    }\n    if (ref.current) {\n      var state = ref.current.getRootState();\n      if (state) {\n        var _route$path;\n        var route = (0, _core.findFocusedRoute)(state);\n        var path = (_route$path = route === null || route === void 0 ? void 0 : route.path) !== null && _route$path !== void 0 ? _route$path : getPathFromStateRef.current(state, configRef.current);\n        if (previousStateRef.current === undefined) {\n          previousStateRef.current = state;\n        }\n        history.replace({\n          path: path,\n          state: state\n        });\n      }\n    }\n    var onStateChange = function _callee2() {\n      var _route$path2, navigation, previousState, state, pendingPath, route, path, _findMatchingState, _findMatchingState2, previousFocusedState, focusedState, historyDelta, nextIndex, currentIndex;\n      return _regeneratorRuntime().async(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            navigation = ref.current;\n            if (!(!navigation || !enabled)) {\n              _context2.next = 3;\n              break;\n            }\n            return _context2.abrupt(\"return\");\n          case 3:\n            previousState = previousStateRef.current;\n            state = navigation.getRootState();\n            pendingPath = pendingPopStatePathRef.current;\n            route = (0, _core.findFocusedRoute)(state);\n            path = (_route$path2 = route === null || route === void 0 ? void 0 : route.path) !== null && _route$path2 !== void 0 ? _route$path2 : getPathFromStateRef.current(state, configRef.current);\n            previousStateRef.current = state;\n            pendingPopStatePathRef.current = undefined;\n            _findMatchingState = findMatchingState(previousState, state), _findMatchingState2 = (0, _slicedToArray2.default)(_findMatchingState, 2), previousFocusedState = _findMatchingState2[0], focusedState = _findMatchingState2[1];\n            if (!(previousFocusedState && focusedState && path !== pendingPath)) {\n              _context2.next = 38;\n              break;\n            }\n            historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);\n            if (!(historyDelta > 0)) {\n              _context2.next = 17;\n              break;\n            }\n            history.push({\n              path: path,\n              state: state\n            });\n            _context2.next = 36;\n            break;\n          case 17:\n            if (!(historyDelta < 0)) {\n              _context2.next = 35;\n              break;\n            }\n            nextIndex = history.backIndex({\n              path: path\n            });\n            currentIndex = history.index;\n            _context2.prev = 20;\n            if (!(nextIndex !== -1 && nextIndex < currentIndex)) {\n              _context2.next = 26;\n              break;\n            }\n            _context2.next = 24;\n            return _regeneratorRuntime().awrap(history.go(nextIndex - currentIndex));\n          case 24:\n            _context2.next = 28;\n            break;\n          case 26:\n            _context2.next = 28;\n            return _regeneratorRuntime().awrap(history.go(historyDelta));\n          case 28:\n            history.replace({\n              path: path,\n              state: state\n            });\n            _context2.next = 33;\n            break;\n          case 31:\n            _context2.prev = 31;\n            _context2.t0 = _context2[\"catch\"](20);\n          case 33:\n            _context2.next = 36;\n            break;\n          case 35:\n            history.replace({\n              path: path,\n              state: state\n            });\n          case 36:\n            _context2.next = 39;\n            break;\n          case 38:\n            history.replace({\n              path: path,\n              state: state\n            });\n          case 39:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, null, null, [[20, 31]], Promise);\n    };\n    return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addListener('state', series(onStateChange));\n  });\n  return {\n    getInitialState: getInitialState\n  };\n}","map":{"version":3,"names":["_core","require","_nonSecure","React","_interopRequireWildcard","_ServerContext","_interopRequireDefault","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_regeneratorRuntime","exports","Op","hasOwn","value","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","fn","arg","type","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","done","methodName","undefined","return","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","_catch","thrown","delegateYield","createMemoryHistory","index","items","pending","interrupt","it","cb","history","_window$history$state","id","window","findIndex","item","backIndex","_ref","path","_ref2","nanoid","pushState","replace","_ref3","_window$history$state2","_window$history$state3","replaceState","go","n","Math","min","interrupted","clearTimeout","timer","title","document","ref","setTimeout","splice","onPopState","last","removeEventListener","addEventListener","listen","listener","findMatchingState","a","b","aHistoryLength","routes","bHistoryLength","aRoute","bRoute","aChildState","bChildState","series","handling","queue","callback","_callee","_callee$","_context","unshift","isUsingLinking","useLinking","_ref4","independent","_ref4$enabled","enabled","config","_ref4$getStateFromPat","getStateFromPath","getStateFromPathDefault","_ref4$getPathFromStat","getPathFromState","getPathFromStateDefault","_ref4$getActionFromSt","getActionFromState","getActionFromStateDefault","useEffect","join","trim","_React$useState","useState","_React$useState2","_slicedToArray2","enabledRef","useRef","configRef","getStateFromPathRef","getPathFromStateRef","getActionFromStateRef","current","server","useContext","ServerContext","getInitialState","useCallback","_server$location","location","pathname","search","thenable","onfulfilled","previousIndexRef","previousStateRef","pendingPopStatePathRef","_previousIndexRef$cur","navigation","previousIndex","resetRoot","rootState","getRootState","some","r","routeNames","includes","console","warn","action","dispatch","e","message","_ref$current","_route$path","route","findFocusedRoute","onStateChange","_callee2","_route$path2","previousState","pendingPath","_findMatchingState","_findMatchingState2","previousFocusedState","focusedState","historyDelta","nextIndex","currentIndex","_callee2$","_context2","t0","addListener"],"sources":["C:\\Users\\annel\\OneDrive\\Documents\\Project\\sam\\ppam\\node_modules\\@react-navigation\\native\\lib\\module\\useLinking.tsx"],"sourcesContent":["import {\n  findFocusedRoute,\n  getActionFromState as getActionFromStateDefault,\n  getPathFromState as getPathFromStateDefault,\n  getStateFromPath as getStateFromPathDefault,\n  NavigationContainerRef,\n  NavigationState,\n  ParamListBase,\n} from '@react-navigation/core';\nimport { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\n\nimport ServerContext from './ServerContext';\nimport type { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype HistoryRecord = {\n  // Unique identifier for this record to match it with window.history.state\n  id: string;\n  // Navigation state object for the history entry\n  state: NavigationState;\n  // Path of the history entry\n  path: string;\n};\n\nconst createMemoryHistory = () => {\n  let index = 0;\n  let items: HistoryRecord[] = [];\n\n  // Pending callbacks for `history.go(n)`\n  // We might modify the callback stored if it was interrupted, so we have a ref to identify it\n  const pending: { ref: unknown; cb: (interrupted?: boolean) => void }[] = [];\n\n  const interrupt = () => {\n    // If another history operation was performed we need to interrupt existing ones\n    // This makes sure that calls such as `history.replace` after `history.go` don't happen\n    // Since otherwise it won't be correct if something else has changed\n    pending.forEach((it) => {\n      const cb = it.cb;\n      it.cb = () => cb(true);\n    });\n  };\n\n  const history = {\n    get index(): number {\n      // We store an id in the state instead of an index\n      // Index could get out of sync with in-memory values if page reloads\n      const id = window.history.state?.id;\n\n      if (id) {\n        const index = items.findIndex((item) => item.id === id);\n\n        return index > -1 ? index : 0;\n      }\n\n      return 0;\n    },\n\n    get(index: number) {\n      return items[index];\n    },\n\n    backIndex({ path }: { path: string }) {\n      // We need to find the index from the element before current to get closest path to go back to\n      for (let i = index - 1; i >= 0; i--) {\n        const item = items[i];\n\n        if (item.path === path) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n\n    push({ path, state }: { path: string; state: NavigationState }) {\n      interrupt();\n\n      const id = nanoid();\n\n      // When a new entry is pushed, all the existing entries after index will be inaccessible\n      // So we remove any existing entries after the current index to clean them up\n      items = items.slice(0, index + 1);\n\n      items.push({ path, state, id });\n      index = items.length - 1;\n\n      // We pass empty string for title because it's ignored in all browsers except safari\n      // We don't store state object in history.state because:\n      // - browsers have limits on how big it can be, and we don't control the size\n      // - while not recommended, there could be non-serializable data in state\n      window.history.pushState({ id }, '', path);\n    },\n\n    replace({ path, state }: { path: string; state: NavigationState }) {\n      interrupt();\n\n      const id = window.history.state?.id ?? nanoid();\n\n      if (items.length) {\n        items[index] = { path, state, id };\n      } else {\n        // This is the first time any state modifications are done\n        // So we need to push the entry as there's nothing to replace\n        items.push({ path, state, id });\n      }\n\n      window.history.replaceState({ id }, '', path);\n    },\n\n    // `history.go(n)` is asynchronous, there are couple of things to keep in mind:\n    // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.\n    // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.\n    // - the `popstate` event fires before the next frame after calling `history.go(n)`.\n    // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.\n    go(n: number) {\n      interrupt();\n\n      if (n > 0) {\n        // We shouldn't go forward more than available index\n        n = Math.min(n, items.length - 1);\n      } else if (n < 0) {\n        // We shouldn't go back more than the 0 index\n        // Otherwise we'll exit the page\n        n = index + n < 0 ? -index : n;\n      }\n\n      if (n === 0) {\n        return;\n      }\n\n      index += n;\n\n      // When we call `history.go`, `popstate` will fire when there's history to go back to\n      // So we need to somehow handle following cases:\n      // - There's history to go back, `history.go` is called, and `popstate` fires\n      // - `history.go` is called multiple times, we need to resolve on respective `popstate`\n      // - No history to go back, but `history.go` was called, browser has no API to detect it\n      return new Promise<void>((resolve, reject) => {\n        const done = (interrupted?: boolean) => {\n          clearTimeout(timer);\n\n          if (interrupted) {\n            reject(new Error('History was changed during navigation.'));\n            return;\n          }\n\n          // There seems to be a bug in Chrome regarding updating the title\n          // If we set a title just before calling `history.go`, the title gets lost\n          // However the value of `document.title` is still what we set it to\n          // It's just not displayed in the tab bar\n          // To update the tab bar, we need to reset the title to something else first (e.g. '')\n          // And set the title to what it was before so it gets applied\n          // It won't work without setting it to empty string coz otherwise title isn't changing\n          // Which means that the browser won't do anything after setting the title\n          const { title } = window.document;\n\n          window.document.title = '';\n          window.document.title = title;\n\n          resolve();\n        };\n\n        pending.push({ ref: done, cb: done });\n\n        // If navigation didn't happen within 100ms, assume that it won't happen\n        // This may not be accurate, but hopefully it won't take so much time\n        // In Chrome, navigation seems to happen instantly in next microtask\n        // But on Firefox, it seems to take much longer, around 50ms from our testing\n        // We're using a hacky timeout since there doesn't seem to be way to know for sure\n        const timer = setTimeout(() => {\n          const index = pending.findIndex((it) => it.ref === done);\n\n          if (index > -1) {\n            pending[index].cb();\n            pending.splice(index, 1);\n          }\n        }, 100);\n\n        const onPopState = () => {\n          const last = pending.pop();\n\n          window.removeEventListener('popstate', onPopState);\n          last?.cb();\n        };\n\n        window.addEventListener('popstate', onPopState);\n        window.history.go(n);\n      });\n    },\n\n    // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`\n    // If we call `history.go(n)` ourselves, we don't want it to trigger the listener\n    // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener\n    listen(listener: () => void) {\n      const onPopState = () => {\n        if (pending.length) {\n          // This was triggered by `history.go(n)`, we shouldn't call the listener\n          return;\n        }\n\n        listener();\n      };\n\n      window.addEventListener('popstate', onPopState);\n\n      return () => window.removeEventListener('popstate', onPopState);\n    },\n  };\n\n  return history;\n};\n\n/**\n * Find the matching navigation state that changed between 2 navigation states\n * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state\n */\nconst findMatchingState = <T extends NavigationState>(\n  a: T | undefined,\n  b: T | undefined\n): [T | undefined, T | undefined] => {\n  if (a === undefined || b === undefined || a.key !== b.key) {\n    return [undefined, undefined];\n  }\n\n  // Tab and drawer will have `history` property, but stack will have history in `routes`\n  const aHistoryLength = a.history ? a.history.length : a.routes.length;\n  const bHistoryLength = b.history ? b.history.length : b.routes.length;\n\n  const aRoute = a.routes[a.index];\n  const bRoute = b.routes[b.index];\n\n  const aChildState = aRoute.state as T | undefined;\n  const bChildState = bRoute.state as T | undefined;\n\n  // Stop here if this is the state object that changed:\n  // - history length is different\n  // - focused routes are different\n  // - one of them doesn't have child state\n  // - child state keys are different\n  if (\n    aHistoryLength !== bHistoryLength ||\n    aRoute.key !== bRoute.key ||\n    aChildState === undefined ||\n    bChildState === undefined ||\n    aChildState.key !== bChildState.key\n  ) {\n    return [a, b];\n  }\n\n  return findMatchingState(aChildState, bChildState);\n};\n\n/**\n * Run async function in series as it's called.\n */\nconst series = (cb: () => Promise<void>) => {\n  // Whether we're currently handling a callback\n  let handling = false;\n  let queue: (() => Promise<void>)[] = [];\n\n  const callback = async () => {\n    try {\n      if (handling) {\n        // If we're currently handling a previous event, wait before handling this one\n        // Add the callback to the beginning of the queue\n        queue.unshift(callback);\n        return;\n      }\n\n      handling = true;\n\n      await cb();\n    } finally {\n      handling = false;\n\n      if (queue.length) {\n        // If we have queued items, handle the last one\n        const last = queue.pop();\n\n        last?.();\n      }\n    }\n  };\n\n  return callback;\n};\n\nlet isUsingLinking = false;\n\ntype Options = LinkingOptions<ParamListBase> & {\n  independent?: boolean;\n};\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef<ParamListBase>>,\n  {\n    independent,\n    enabled = true,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n    getActionFromState = getActionFromStateDefault,\n  }: Options\n) {\n  React.useEffect(() => {\n    if (independent) {\n      return undefined;\n    }\n\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You are not using both 'linking' prop and 'useLinking'\",\n          \"- You don't have 'useLinking' in multiple components\",\n        ]\n          .join('\\n')\n          .trim()\n      );\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  const [history] = React.useState(createMemoryHistory);\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n  const getActionFromStateRef = React.useRef(getActionFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n    getActionFromStateRef.current = getActionFromState;\n  });\n\n  const server = React.useContext(ServerContext);\n\n  const getInitialState = React.useCallback(() => {\n    let value: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const location =\n        server?.location ??\n        (typeof window !== 'undefined' ? window.location : undefined);\n\n      const path = location ? location.pathname + location.search : undefined;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const previousIndexRef = React.useRef<number | undefined>(undefined);\n  const previousStateRef = React.useRef<NavigationState | undefined>(undefined);\n  const pendingPopStatePathRef = React.useRef<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    previousIndexRef.current = history.index;\n\n    return history.listen(() => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const path = location.pathname + location.search;\n      const index = history.index;\n\n      const previousIndex = previousIndexRef.current ?? 0;\n\n      previousIndexRef.current = index;\n      pendingPopStatePathRef.current = path;\n\n      // When browser back/forward is clicked, we first need to check if state object for this index exists\n      // If it does we'll reset to that state object\n      // Otherwise, we'll handle it like a regular deep link\n      const record = history.get(index);\n\n      if (record?.path === path && record?.state) {\n        navigation.resetRoot(record.state);\n        return;\n      }\n\n      const state = getStateFromPathRef.current(path, configRef.current);\n\n      // We should only dispatch an action when going forward\n      // Otherwise the action will likely add items to history, which would mess things up\n      if (state) {\n        // Make sure that the routes in the state exist in the root navigator\n        // Otherwise there's an error in the linking configuration\n        const rootState = navigation.getRootState();\n\n        if (state.routes.some((r) => !rootState?.routeNames.includes(r.name))) {\n          console.warn(\n            \"The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.\"\n          );\n          return;\n        }\n\n        if (index > previousIndex) {\n          const action = getActionFromStateRef.current(\n            state,\n            configRef.current\n          );\n\n          if (action !== undefined) {\n            try {\n              navigation.dispatch(action);\n            } catch (e) {\n              // Ignore any errors from deep linking.\n              // This could happen in case of malformed links, navigation object not being initialized etc.\n              console.warn(\n                `An error occurred when trying to handle the link '${path}': ${e.message}`\n              );\n            }\n          } else {\n            navigation.resetRoot(state);\n          }\n        } else {\n          navigation.resetRoot(state);\n        }\n      } else {\n        // if current path didn't return any state, we should revert to initial state\n        navigation.resetRoot(state);\n      }\n    });\n  }, [enabled, history, ref]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current) {\n      // We need to record the current metadata on the first render if they aren't set\n      // This will allow the initial state to be in the history entry\n      const state = ref.current.getRootState();\n\n      if (state) {\n        const route = findFocusedRoute(state);\n        const path =\n          route?.path ?? getPathFromStateRef.current(state, configRef.current);\n\n        if (previousStateRef.current === undefined) {\n          previousStateRef.current = state;\n        }\n\n        history.replace({ path, state });\n      }\n    }\n\n    const onStateChange = async () => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousState = previousStateRef.current;\n      const state = navigation.getRootState();\n\n      const pendingPath = pendingPopStatePathRef.current;\n      const route = findFocusedRoute(state);\n      const path =\n        route?.path ?? getPathFromStateRef.current(state, configRef.current);\n\n      previousStateRef.current = state;\n      pendingPopStatePathRef.current = undefined;\n\n      // To detect the kind of state change, we need to:\n      // - Find the common focused navigation state in previous and current state\n      // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace\n      // - If no common focused navigation state found, it's a replace\n      const [previousFocusedState, focusedState] = findMatchingState(\n        previousState,\n        state\n      );\n\n      if (\n        previousFocusedState &&\n        focusedState &&\n        // We should only handle push/pop if path changed from what was in last `popstate`\n        // Otherwise it's likely a change triggered by `popstate`\n        path !== pendingPath\n      ) {\n        const historyDelta =\n          (focusedState.history\n            ? focusedState.history.length\n            : focusedState.routes.length) -\n          (previousFocusedState.history\n            ? previousFocusedState.history.length\n            : previousFocusedState.routes.length);\n\n        if (historyDelta > 0) {\n          // If history length is increased, we should pushState\n          // Note that path might not actually change here, for example, drawer open should pushState\n          history.push({ path, state });\n        } else if (historyDelta < 0) {\n          // If history length is decreased, i.e. entries were removed, we want to go back\n\n          const nextIndex = history.backIndex({ path });\n          const currentIndex = history.index;\n\n          try {\n            if (nextIndex !== -1 && nextIndex < currentIndex) {\n              // An existing entry for this path exists and it's less than current index, go back to that\n              await history.go(nextIndex - currentIndex);\n            } else {\n              // We couldn't find an existing entry to go back to, so we'll go back by the delta\n              // This won't be correct if multiple routes were pushed in one go before\n              // Usually this shouldn't happen and this is a fallback for that\n              await history.go(historyDelta);\n            }\n\n            // Store the updated state as well as fix the path if incorrect\n            history.replace({ path, state });\n          } catch (e) {\n            // The navigation was interrupted\n          }\n        } else {\n          // If history length is unchanged, we want to replaceState\n          history.replace({ path, state });\n        }\n      } else {\n        // If no common navigation state was found, assume it's a replace\n        // This would happen if the user did a reset/conditionally changed navigators\n        history.replace({ path, state });\n      }\n    };\n\n    // We debounce onStateChange coz we don't want multiple state changes to be handled at one time\n    // This could happen since `history.go(n)` is asynchronous\n    // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up\n    return ref.current?.addListener('state', series(onStateChange));\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}